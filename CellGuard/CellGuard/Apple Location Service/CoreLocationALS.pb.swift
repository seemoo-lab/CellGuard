// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: core-location-als.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct AlsProto_ALSLocationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknown3: Int32 {
    get {return _unknown3 ?? 0}
    set {_unknown3 = newValue}
  }
  /// Returns true if `unknown3` has been explicitly set.
  var hasUnknown3: Bool {return self._unknown3 != nil}
  /// Clears the value of `unknown3`. Subsequent reads from it will return its default value.
  mutating func clearUnknown3() {self._unknown3 = nil}

  var unknown4: Int32 {
    get {return _unknown4 ?? 0}
    set {_unknown4 = newValue}
  }
  /// Returns true if `unknown4` has been explicitly set.
  var hasUnknown4: Bool {return self._unknown4 != nil}
  /// Clears the value of `unknown4`. Subsequent reads from it will return its default value.
  mutating func clearUnknown4() {self._unknown4 = nil}

  var cell: AlsProto_ALSLocationRequest.RequestCell {
    get {return _cell ?? AlsProto_ALSLocationRequest.RequestCell()}
    set {_cell = newValue}
  }
  /// Returns true if `cell` has been explicitly set.
  var hasCell: Bool {return self._cell != nil}
  /// Clears the value of `cell`. Subsequent reads from it will return its default value.
  mutating func clearCell() {self._cell = nil}

  var unknown31: Int32 {
    get {return _unknown31 ?? 0}
    set {_unknown31 = newValue}
  }
  /// Returns true if `unknown31` has been explicitly set.
  var hasUnknown31: Bool {return self._unknown31 != nil}
  /// Clears the value of `unknown31`. Subsequent reads from it will return its default value.
  mutating func clearUnknown31() {self._unknown31 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct RequestCell {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// https://en.wikipedia.org/wiki/Mobile_country_code
    var mcc: Int32 {
      get {return _mcc ?? 0}
      set {_mcc = newValue}
    }
    /// Returns true if `mcc` has been explicitly set.
    var hasMcc: Bool {return self._mcc != nil}
    /// Clears the value of `mcc`. Subsequent reads from it will return its default value.
    mutating func clearMcc() {self._mcc = nil}

    /// Germany: https://de.wikipedia.org/wiki/Mobilfunknetzkennzahl
    var mnc: Int32 {
      get {return _mnc ?? 0}
      set {_mnc = newValue}
    }
    /// Returns true if `mnc` has been explicitly set.
    var hasMnc: Bool {return self._mnc != nil}
    /// Clears the value of `mnc`. Subsequent reads from it will return its default value.
    mutating func clearMnc() {self._mnc = nil}

    /// https://en.wikipedia.org/wiki/GSM_Cell_ID
    /// If cellID == Long.MAX_VALUE -> only rough location for tacID
    var cellID: Int64 {
      get {return _cellID ?? 0}
      set {_cellID = newValue}
    }
    /// Returns true if `cellID` has been explicitly set.
    var hasCellID: Bool {return self._cellID != nil}
    /// Clears the value of `cellID`. Subsequent reads from it will return its default value.
    mutating func clearCellID() {self._cellID = nil}

    /// http://wiki.opencellid.org/wiki/FAQ#What_is_the_difference_between_the_LAC_and_TAC_in_the_LTE_Modem_Status.3F
    /// https://ec.europa.eu/eurostat/cros/content/Glossary%3ALocation_Area_Code/Tracking_Area_Code_%28LAC/TAC%29_en
    var tacID: Int32 {
      get {return _tacID ?? 0}
      set {_tacID = newValue}
    }
    /// Returns true if `tacID` has been explicitly set.
    var hasTacID: Bool {return self._tacID != nil}
    /// Clears the value of `tacID`. Subsequent reads from it will return its default value.
    mutating func clearTacID() {self._tacID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _mcc: Int32? = nil
    fileprivate var _mnc: Int32? = nil
    fileprivate var _cellID: Int64? = nil
    fileprivate var _tacID: Int32? = nil
  }

  init() {}

  fileprivate var _unknown3: Int32? = nil
  fileprivate var _unknown4: Int32? = nil
  fileprivate var _cell: AlsProto_ALSLocationRequest.RequestCell? = nil
  fileprivate var _unknown31: Int32? = nil
}

struct AlsProto_ALSLocationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of nearby cell towers with location data
  var cells: [AlsProto_ALSLocationResponse.ResponseCell] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ResponseCellLocation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// X * pow(10, -8)
    var latitude: Int64 {
      get {return _latitude ?? 0}
      set {_latitude = newValue}
    }
    /// Returns true if `latitude` has been explicitly set.
    var hasLatitude: Bool {return self._latitude != nil}
    /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
    mutating func clearLatitude() {self._latitude = nil}

    /// X * pow(10, -8)
    var longitude: Int64 {
      get {return _longitude ?? 0}
      set {_longitude = newValue}
    }
    /// Returns true if `longitude` has been explicitly set.
    var hasLongitude: Bool {return self._longitude != nil}
    /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
    mutating func clearLongitude() {self._longitude = nil}

    /// in meters
    var accuracy: Int32 {
      get {return _accuracy ?? 0}
      set {_accuracy = newValue}
    }
    /// Returns true if `accuracy` has been explicitly set.
    var hasAccuracy: Bool {return self._accuracy != nil}
    /// Clears the value of `accuracy`. Subsequent reads from it will return its default value.
    mutating func clearAccuracy() {self._accuracy = nil}

    /// only observed value: 0
    var locationType: Int32 {
      get {return _locationType ?? 0}
      set {_locationType = newValue}
    }
    /// Returns true if `locationType` has been explicitly set.
    var hasLocationType: Bool {return self._locationType != nil}
    /// Clears the value of `locationType`. Subsequent reads from it will return its default value.
    mutating func clearLocationType() {self._locationType = nil}

    /// in meters
    var reach: Int32 {
      get {return _reach ?? 0}
      set {_reach = newValue}
    }
    /// Returns true if `reach` has been explicitly set.
    var hasReach: Bool {return self._reach != nil}
    /// Clears the value of `reach`. Subsequent reads from it will return its default value.
    mutating func clearReach() {self._reach = nil}

    /// TODO: How often the cell was seen by Apple devices?
    var score: Int32 {
      get {return _score ?? 0}
      set {_score = newValue}
    }
    /// Returns true if `score` has been explicitly set.
    var hasScore: Bool {return self._score != nil}
    /// Clears the value of `score`. Subsequent reads from it will return its default value.
    mutating func clearScore() {self._score = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _latitude: Int64? = nil
    fileprivate var _longitude: Int64? = nil
    fileprivate var _accuracy: Int32? = nil
    fileprivate var _locationType: Int32? = nil
    fileprivate var _reach: Int32? = nil
    fileprivate var _score: Int32? = nil
  }

  struct ResponseCell {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// https://en.wikipedia.org/wiki/Mobile_country_code
    var mcc: Int32 {
      get {return _mcc ?? 0}
      set {_mcc = newValue}
    }
    /// Returns true if `mcc` has been explicitly set.
    var hasMcc: Bool {return self._mcc != nil}
    /// Clears the value of `mcc`. Subsequent reads from it will return its default value.
    mutating func clearMcc() {self._mcc = nil}

    /// Germany: https://de.wikipedia.org/wiki/Mobilfunknetzkennzahl
    var mnc: Int32 {
      get {return _mnc ?? 0}
      set {_mnc = newValue}
    }
    /// Returns true if `mnc` has been explicitly set.
    var hasMnc: Bool {return self._mnc != nil}
    /// Clears the value of `mnc`. Subsequent reads from it will return its default value.
    mutating func clearMnc() {self._mnc = nil}

    /// https://en.wikipedia.org/wiki/GSM_Cell_ID
    /// If cellID == -1 -> only rough location for tacID
    var cellID: Int64 {
      get {return _cellID ?? 0}
      set {_cellID = newValue}
    }
    /// Returns true if `cellID` has been explicitly set.
    var hasCellID: Bool {return self._cellID != nil}
    /// Clears the value of `cellID`. Subsequent reads from it will return its default value.
    mutating func clearCellID() {self._cellID = nil}

    /// http://wiki.opencellid.org/wiki/FAQ#What_is_the_difference_between_the_LAC_and_TAC_in_the_LTE_Modem_Status.3F
    /// https://ec.europa.eu/eurostat/cros/content/Glossary%3ALocation_Area_Code/Tracking_Area_Code_%28LAC/TAC%29_en
    var tacID: Int32 {
      get {return _tacID ?? 0}
      set {_tacID = newValue}
    }
    /// Returns true if `tacID` has been explicitly set.
    var hasTacID: Bool {return self._tacID != nil}
    /// Clears the value of `tacID`. Subsequent reads from it will return its default value.
    mutating func clearTacID() {self._tacID = nil}

    var location: AlsProto_ALSLocationResponse.ResponseCellLocation {
      get {return _location ?? AlsProto_ALSLocationResponse.ResponseCellLocation()}
      set {_location = newValue}
    }
    /// Returns true if `location` has been explicitly set.
    var hasLocation: Bool {return self._location != nil}
    /// Clears the value of `location`. Subsequent reads from it will return its default value.
    mutating func clearLocation() {self._location = nil}

    var unknown6: Int32 {
      get {return _unknown6 ?? 0}
      set {_unknown6 = newValue}
    }
    /// Returns true if `unknown6` has been explicitly set.
    var hasUnknown6: Bool {return self._unknown6 != nil}
    /// Clears the value of `unknown6`. Subsequent reads from it will return its default value.
    mutating func clearUnknown6() {self._unknown6 = nil}

    var unknown7: Int32 {
      get {return _unknown7 ?? 0}
      set {_unknown7 = newValue}
    }
    /// Returns true if `unknown7` has been explicitly set.
    var hasUnknown7: Bool {return self._unknown7 != nil}
    /// Clears the value of `unknown7`. Subsequent reads from it will return its default value.
    mutating func clearUnknown7() {self._unknown7 = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _mcc: Int32? = nil
    fileprivate var _mnc: Int32? = nil
    fileprivate var _cellID: Int64? = nil
    fileprivate var _tacID: Int32? = nil
    fileprivate var _location: AlsProto_ALSLocationResponse.ResponseCellLocation? = nil
    fileprivate var _unknown6: Int32? = nil
    fileprivate var _unknown7: Int32? = nil
  }

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension AlsProto_ALSLocationRequest: @unchecked Sendable {}
extension AlsProto_ALSLocationRequest.RequestCell: @unchecked Sendable {}
extension AlsProto_ALSLocationResponse: @unchecked Sendable {}
extension AlsProto_ALSLocationResponse.ResponseCellLocation: @unchecked Sendable {}
extension AlsProto_ALSLocationResponse.ResponseCell: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "als_proto"

extension AlsProto_ALSLocationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ALSLocationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "unknown3"),
    4: .same(proto: "unknown4"),
    25: .same(proto: "cell"),
    31: .same(proto: "unknown31"),
  ]

  public var isInitialized: Bool {
    if self._unknown3 == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._unknown3) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._unknown4) }()
      case 25: try { try decoder.decodeSingularMessageField(value: &self._cell) }()
      case 31: try { try decoder.decodeSingularInt32Field(value: &self._unknown31) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._unknown3 {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._unknown4 {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._cell {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    } }()
    try { if let v = self._unknown31 {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 31)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AlsProto_ALSLocationRequest, rhs: AlsProto_ALSLocationRequest) -> Bool {
    if lhs._unknown3 != rhs._unknown3 {return false}
    if lhs._unknown4 != rhs._unknown4 {return false}
    if lhs._cell != rhs._cell {return false}
    if lhs._unknown31 != rhs._unknown31 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AlsProto_ALSLocationRequest.RequestCell: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = AlsProto_ALSLocationRequest.protoMessageName + ".RequestCell"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mcc"),
    2: .same(proto: "mnc"),
    3: .same(proto: "cellId"),
    4: .same(proto: "tacId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._mcc) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._mnc) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._cellID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._tacID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mcc {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._mnc {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cellID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._tacID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AlsProto_ALSLocationRequest.RequestCell, rhs: AlsProto_ALSLocationRequest.RequestCell) -> Bool {
    if lhs._mcc != rhs._mcc {return false}
    if lhs._mnc != rhs._mnc {return false}
    if lhs._cellID != rhs._cellID {return false}
    if lhs._tacID != rhs._tacID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AlsProto_ALSLocationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ALSLocationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    22: .same(proto: "cells"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 22: try { try decoder.decodeRepeatedMessageField(value: &self.cells) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cells.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cells, fieldNumber: 22)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AlsProto_ALSLocationResponse, rhs: AlsProto_ALSLocationResponse) -> Bool {
    if lhs.cells != rhs.cells {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AlsProto_ALSLocationResponse.ResponseCellLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = AlsProto_ALSLocationResponse.protoMessageName + ".ResponseCellLocation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
    3: .same(proto: "accuracy"),
    4: .same(proto: "locationType"),
    11: .same(proto: "reach"),
    12: .same(proto: "score"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._latitude) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._longitude) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._accuracy) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._locationType) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self._reach) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self._score) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._latitude {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._longitude {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._accuracy {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._locationType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._reach {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._score {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AlsProto_ALSLocationResponse.ResponseCellLocation, rhs: AlsProto_ALSLocationResponse.ResponseCellLocation) -> Bool {
    if lhs._latitude != rhs._latitude {return false}
    if lhs._longitude != rhs._longitude {return false}
    if lhs._accuracy != rhs._accuracy {return false}
    if lhs._locationType != rhs._locationType {return false}
    if lhs._reach != rhs._reach {return false}
    if lhs._score != rhs._score {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AlsProto_ALSLocationResponse.ResponseCell: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = AlsProto_ALSLocationResponse.protoMessageName + ".ResponseCell"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mcc"),
    2: .same(proto: "mnc"),
    3: .same(proto: "cellId"),
    4: .same(proto: "tacId"),
    5: .same(proto: "location"),
    6: .same(proto: "unknown6"),
    7: .same(proto: "unknown7"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._mcc) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._mnc) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._cellID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._tacID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._unknown6) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self._unknown7) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mcc {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._mnc {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cellID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._tacID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._unknown6 {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._unknown7 {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AlsProto_ALSLocationResponse.ResponseCell, rhs: AlsProto_ALSLocationResponse.ResponseCell) -> Bool {
    if lhs._mcc != rhs._mcc {return false}
    if lhs._mnc != rhs._mnc {return false}
    if lhs._cellID != rhs._cellID {return false}
    if lhs._tacID != rhs._tacID {return false}
    if lhs._location != rhs._location {return false}
    if lhs._unknown6 != rhs._unknown6 {return false}
    if lhs._unknown7 != rhs._unknown7 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
